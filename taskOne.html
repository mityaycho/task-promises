<script>
  let myPromise = new Promise((resolve) => {
    setTimeout(() => alert('Hello'), 2000);
    resolve();
  });

  myPromise.then(( ) => {
    console.log("myPromise зарезолвился, и я узнал об этом");
  })
</script>

<!--промис - это объект, у которого есть 3 состояния и метод then-->

<!--Промис (обещание) - это объект, который может находится в одном из 3 состояний:-->

<!--1. pending (в процессе выполнения обещания)-->
<!--2. rejected (обещание не выполнил)-->
<!--3. resolved (обещание выполнил)-->

<!--Когда обещание выполнится мы можем узнать об этом, подписавшись (отдав колбек)-->
<!--с помощью метода промиса - then-->

<!--Как и любой объект промис создаётся с помощью конструктора.-->

<!--Создайте Promise, который обещает нам показать alert('Hello');-->



<!--// внутрь Promise передаём колбэк-функцию, которая собственно и есть та логика, которую промис обещает выполнить.-->
<!--let myPromise = new Promise(() => {-->
<!--alert('Hello');-->
<!--});-->

<!--// ниже по коду мы можем подписаться, на промис, чтобы он (промис) вызвал нашу функцию, когда он (промис) зарезолвится. Для этого передаём в метод then колбэк-функцию)-->
<!--myPromise.then(( ) => {-->
<!--console.log("myPromise зарезолвился, и я узнал об этом");-->
<!--})-->

<!--Итак, алерт мы увидели, но в консоли пусто. То есть обещание фактически выполнено, но колбэк, переданный в then, промис не вызвал, то есть не сообщил нам, что промис зарезолвился.-->

<!--Почему так? Потому что промис не зарезолвился, но обещание выполнил.. А как ему зарезолвиться??? Нужно вызвать специальную функцию, которая переведёт текущий промис в состояние ЗАРЕЗОЛВИЛСЯ. Вызвать эту функцию нужно внутри колбэка-обещания. Функция эта засунется внутрь этого колбэка в качестве первого параметра.-->



<!--let myPromise = new Promise((resolve) => {-->
<!--alert('Hello');-->
<!--resolve();-->
<!--});-->
<!--А теперь перепешите свой промис, чтобы он обещал показать alert через 2 секунды (внутри промиса нужно вызвать setTimeout)...-->

<!--То есть внутри callback фигачим setTimeout, а внутри setTimeout показываем alert и делаем resolve-->


<!--В отдельном файле создайте новый промис (скопируйте старый, который обещает сгенерировать рандомное число и показать его в alert через 3 секунды (с помощью Math.random)-->

<!--И так же подпишитесь на resolve-промиса, и выведите в консоль сообщение.-->

<!--Должны увидеть в консоли рандомное дробное число от 0 до 1 и в консоли сообщение, что подписчик на промис узнал о том, что промис зарезолвился-->


<!--Когда промис резолвится, он может отправить своим подписчикам какие-то данные, которые он там внутри своего колбэка-обещания получил.-->

<!--Вспомним, когда мы делаем ajax запрос, подписываемся с помощью then на этот промис, наш подписчик от промиса получит данные:-->



<!--axios.get('https://google.com/blabla')-->
<!--.then( (res) => { console.log(res); } )-->

<!--Давайте подписчику на наш промис отправим рандомно сгенерированное число. Для этого всего навсего нужно отправить это число в функцию resolve-->

<!--Удалите alert из тела обещания-колбэка, пусть промис просто теперь обещает сгенерировать рандомное число и отправить его подписчикам. Исправьте подписчик, добавив в него параметр number (название параметру можно дать любое) и внутри подписчика выведите это число в консоль. Обновляйте страницу, и в консоли каждый раз будете видеть новое число:-->



<!--Чаще всего промис не создают как бы так просто, чтобы тут же на него подписываться. Чаще всего у нас есть какая-то функция, мы её вызываем, и она внутри себя создаёт новый промис и возвращает его нам (на подобие axios.get, axios.post и так далее)-->

<!--Давайте создадим функцию doAfter, которая:-->
<!--1. … которая принимает параметром кол-во секунд, сколько ждать-->
<!--2. … которая внутри себя будет создавать Promise, обещание которого - просто ждать переданное на этапе 1 кол-во секунд и резолвится через это время.-->
<!--3. ... которая возвращает созданный промис наружу.-->

<!--И когда у нас будет такая функция, мы сможем ей вот так вот пользовать (как заменой seTimeout):-->


<!--doAfter(5).then( () => console.log('я сработал через 5 секунд') );-->
<!--doAfter(3).then( () => console.log('а я сработал через 3 секунд') );-->
<!--doAfter(10).then( () => console.log('я сработал через 10 секунд') );-->

<!--Давайте внимательно разберемся с тем, что происходит с функцией doAfter-->


<!--let promise3 = doAfter(3);-->
<!--let promise5 = doAfter(5);-->

<!--promise5.then( () => console.log('я сработал через 5 секунд') );-->
<!--promise3.then( () => console.log('а я сработал через 3 секунд') );-->

<!--То есть doAfter нам возвращает promise… И можем их словить вот так вот в переменные и потом на них подписываться!-->

<!--Скопируйте этот код в отдельный файл:-->



<!--let promise3 = doAfter(3);-->
<!--promise3.then( () => console.log('я сработал через 3 секунд') );-->
<!--promise3.then( () => console.log('и я тоже следом сработал через 3 секунд') );-->
<!--promise3.then( () => console.log('и я') );-->

<!--Что здесь происходит? Мы много раз подписались на событие ПРОМИС_ЗАРЕЗОЛВИЛСЯ, 3 раза обратившись к промису через метод then-->


<!--А если мы подпишимся на промис после того, как он зарезолвится? Сделайте promise3.then из примера выше внутри setTimout c задержкой в 5 секунд… И сделайте вывод.-->





<!--промис - это объект, у которого есть 3 состояния и метод then-->

<!--Метод = функция. Значит then - это функция. А возвращает нам что-либо эта функция? Да, возвращает НОВЫЙ ПРОМИС, который зарезолвится после того, как зарезолвится промис, then у которого мы вызвали.-->


<!--let pr1 = doAfter(3);-->
<!--let pr2 = pr1.then( () => console.log('Мой промис зарезолвился') );-->
<!--pr2.then( () => console.log('Мой промис тоже зарезолвился следом за pr1'));-->

<!--pr1 - промис, который зарезолвится через 3 секунды-->
<!--pr2 - промис, который во 2-ой строке кода породил метод then. Важно: pr2 нам вернул не колбэк, который мы передали в then, а именно сам метод then-->
<!--Мы ничего не знаем про внутренности pr2, только то, что он зарезолвится после того, как зарезолвится pr1 и (внимание) отработает колбэк, переданный в then, из которого он вылез-->

<!--Вопрос! Если мы вначале 3 строчки перед pr2.then допишем let something =-->
<!--Что будет в переменной something? :)-->


<!--Благодаря тому, что then возвращает нам другой промис, мы можем выстраивать then в цепочку.-->

<!--То что мы написали в примере выше, обычно пишут так:-->



<!--Так как каждый then возвращает промис, мы можем бесконечно эту цепочку продолжать.-->

<!--Пока учимся, будем писать КАЖДЫЙ пример в двух вариантах-->



<!--Промис - это объект, у которого есть 3 состояния и метод then.-->
<!--Каждый then возвращает новый promise, который резолвится после того, как зарезолвится промис, из then которого он вылез.-->



<!--Зарефакторим, вынеся коллбэки в переменные:-->

<!--let callback1 = () => console.log('Мой промис зарезолвился');-->
<!--let callback2 = () => console.log('Мой промис тоже зарезолвился следом');-->

<!--let pr1 = doAfter(3);-->
<!--let pr2 = pr1.then(callback1);-->
<!--pr2.then(callback2);-->


<!--Важен 3 пункт! Потому что если callback1 что-то вернёт, то это что-то будет тем, чем зарезолвится pr2-->


<!--Напишите код так, чтобы первый колбэк что-то вернул, и тогда pr2 зарезолвится этим и callback2 получит это что-то! Напишите сами!-->
<!--В двух версиях!-->


<!--Если писать через цепочку и при этом зафигачить в then-ы анонимные колбэки, то будет визуально понятнее, что куда прыгает (хотя может быть и не ясно, что происходит внутри):-->










<!--В новый файл добавьте этот код:-->



<!--let pr = new Promise( (resolve) => {-->
<!--let data = {-->
<!--cities: [{title: "Minsk"}, {title: "Kiev"}],-->
<!--website: "it-kamasutra.com"-->
<!--};-->
<!--resolve(data);-->
<!--});-->

<!--pr.then( data => {-->
<!--console.log(data);-->
<!--})-->
<!--.then( website => {-->
<!--console.log(website);-->
<!--})-->




<!--доработайте этот код так, чтобы во втором коллбэке второго then мы увидели “website”.-->
<!--Перепишите этот код более детально, записывая каждый промис, возвращаемый из then в отдельную переменную.-->



<!--создайте новый файл и подключите в него этот фейковый axios.js, который умеет делать get-запросы и post-запросы, и api.js-->



<!--<script src="axios.js"></script>-->
<!--<script src="api.js"></script>-->

<!--<script>-->
<!--  api.sendStudentsCountToItKamasutra(20)-->
<!--    .then(res => {-->
<!--      console.log(res);-->
<!--    });-->
<!--</script>-->

<!--Посмотрите в консоли, какой результат нам вернётся. Много лишнего апишка нам возвращает, хотелось бы просто получить от неё объект с данными.-->

<!--Переделайте по аналогии с предыдущим примером так, чтобы апишка нам возвращала другой промис, который зарезолвится не всем объектом, а только тем, что нужно! Переделайте так же 2 других метода-->



<!--Мы можем получить обещание, которое выполнится, когда все подобещания будут выполнены.-->
<!--Техническими словами: некоторый общий Promise зарезолвится, когда зарезолвятся все другие входящие в него Promise-ы-->

<!--let pr1 = doAfter(4); // один промис-->
<!--let pr2 = doAfter(7); // второй промис-->

<!--pr1.then( () => console.log("pr1 resolved") ); // индивидуально подписываемся на каждый-->
<!--pr2.then( () => console.log("pr2 resolved") );-->

<!--let aggregatedPromise = Promise.all([pr1, pr2]); // получаем общий промис-->

<!--aggregatedPromise.then( () => console.log("pr1 and pr2 resolved")); // сработает наш подписчик ТОЛЬКО когда все промисы, переданные в массиве в all будут resolved-->





<!--А теперь по аналогии с doAfter создайте функцию (копипастом)-->
<!--getRandomAfter, которая будет рандомно выдавать какое-то число через заданное кол-во секунд-->



<!--getRandomAfter(4).then( number => console.log(`я получил ${number} спустя 4 секунды`))-->

<!--А потом давайте напишем так:-->



<!--let promises = [getRandomAfter(1),getRandomAfter(2), getRandomAfter(3)];-->
<!--let commonPromise = Promises.all(promises);-->
<!--commonPromise.then( () => {-->
<!--// как вывести здесь все 3 числа?? гуглим Promises.all-->
<!--} );-->

<!--А это пример из жизни:-->


<!--api.getVacanciesCountFromMicrosoft()-->
<!--.then(data => {-->
<!--console.log(data);-->
<!--});-->

<!--api.getVacanciesCountFromGoogle()-->
<!--.then(data => {-->
<!--console.log(data);-->
<!--});-->

<!--api.sendStudentsCountToItKamasutra(XXXX)-->
<!--.then(data => {-->
<!--console.log(data);-->
<!--});-->

<!--Нужно в камасутру отправить суммарное кол-во вакансий значение, которое получится в ответах от компании microsoft и google-->
